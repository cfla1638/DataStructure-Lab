# 线性表及其应用 约瑟夫环

## 实验要求

1. 问题描述：约瑟夫问题的一种描述是：编号为1,2,…,n的n个人按顺时针方向围坐一圈，每人持有一个密码（正整数）。初始的报数上限值m由用户在测试时输入，然后从第一个人开始按顺时针的方向从1开始顺序报数，报到m时停止报数。报m的人出列，将他的密码作为新的m的值，从他在顺时针方向上的下一个人开始重新从1报数，如此下去，直至所有人全部出列为止。请编写一个程序计算出列顺序。

2. 基本要求：用单向循环链表来模拟此过程，按照出列的顺序输出各人的编号。
3. 第一组测试数据：n=7，m的初值为20， 7个人的密码依次为：3,1,7,2,4,8,4。那么正确的出列顺序应为6,1,4,7,2,3,5。各位同学需要自己补充更多测试数据，以便充分测试各种情况，找到代码中的问题。
4. 实现提示：程序运行后，首先要求用户输入人数n和初始报数上限值m，然后读取各人的密码。一般n≤30。此题所用的循环链表中不需要“头结点”，请注意空表和非空表的界限。
5. 选做内容：使用顺序表或其它数据结构来模拟此过程，并和单向循环链表的做法进行时间复杂度和空间复杂度的比较。

## 项目设计

**【循环链表写法】**

​	本实验不适合使用面向对象的写法，因为约瑟夫环问题的循环链表写法是利用了直接操作指针，获得后继的便利。而面向对象封装了原始的指针，如果我们要使用面向对象的写法，需要为它提供一个迭代器。这对该问题来说过于复杂了，因此对于这个问题本项目使用面向过程的C语言写法。

​	我们拥有一个循环链表结构构成的环，循环链表的结点里存储着每个人的密码和其索引。我们使用循环链表即可对约瑟夫环进行模拟。

**【选做内容: 顺序表写法】**

​	使用了一个数组来模拟约瑟夫环，删除使用标记删除法。

​	数组`list[i]` 存储第`i+1`人的密码

​	因为所有人都要从1开始报数，因此每个人的密码必然大于零。基于此，我们将被删除的元素乘以-1，即可标记删除，不需要使用多余的空间。



## 总结分析

**【Debug】**

1. 本项目的`void Remove(CirLinkedList *, NodePtr *)` 函数

   第二个参数是传入了要删除的结点指针，并在这个指针中返回已删除结点的前驱。这个函数其实是在remove语义的基础上，为了方便模拟约瑟夫环，再添加了返回其前驱的语义。

   为什么要返回前驱而不是后继。事实上，最开始我就是将此函数的功能设计为“删除第二个参数所指向的结点，并返回其后继”。但如果使用这种设计，事实上我们就假定了每个人的密码必须大于或等于1。可是，题目的意思表明，每个人从1开始报数，这似乎意味着，每个人的密码一定大于等于1。但是我们使用了取模的方法对算法进行了优化，优化之后就会出现某人的密码为0的情况，这种情况就是:当某人的密码是约瑟夫环长的一个因子，这时，取模之后的密码为0。对于这种情况，返回其后继的做法就不能处理了。综上，删除函数返回要删除的结点的后继和我们使用取模方法优化算法，这两种做法是互斥的。因此我们要避开返回删除节点后继的做法，返回被删除结点的前驱。

2. 忘记删除结点之后，改变rear指针的指向。



**【两种做法的时间复杂度分析】**

时间复杂度：

循环链表  最坏情况是O(n2), 稳定

顺序表   理想情况下O(n2)，但不稳定

 

空间复杂度：

循环链表  O(n) (申请了多余的空间存储指针和元素的编号)

顺序表   O(1)

## 源代码

顺序表版本： `sqlist_version.cpp`

循环链表版本：`cirlist_version.cpp`