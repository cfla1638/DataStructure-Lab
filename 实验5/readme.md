# 哈夫曼树

## 实验内容

1. 问题描述：利用哈夫曼编码进行通信可以大大提高信道利用率，缩短信息传输时间，降低传输成本。但是，这要求在发送端通过一个编码系统对待传数据预先编码，在接收端将传来的数据进行译码（复原）。对于双工信道（即可以双向传输信息的信道），每端都需要一个完整的编／译码系统。试为这样的信息收发站写一个哈夫曼码的编／译码系统。

 2. 基本要求：一个完整的系统应具有以下功能：

    Ｉ：初始化（Initialization）。用户输入字符个数n，n个字符和n个权值，建立哈夫曼树，并按自选的格式存入文本文件hfmTree.txt中。

    Ｅ：编码（Encoding）。利用已建好的哈夫曼树（如不在内存，则从文件hfmTree.txt中读入），对文本文件ToBeTranslated.txt中的正文进行编码，然后将结果存入文本文件CodeFile.txt中。

    Ｄ：译码（Decoding）。利用已建好的哈夫曼树将文件CodeFile.txt中的代码进行译码，结果存入文本文件TextFile.txt中。

    Ｐ：输出代码文件（Print）。将文件CodeFile.txt以每行50个字符的紧凑格式显示在屏幕上，并把屏幕上内容存入文本文件CodePrint.txt。

    Ｔ：输出哈夫曼树（Tree printing）。将已在内存中的哈夫曼树以直观的方式（树形或凹入表形式）显示在屏幕上，并把屏幕上的内容存入文本文件TreePrint.txt中。

3. 测试数据：见数据结构题集（C语言版）Ｐ149测试数据。

4. 实现提示：

   与文本文件的读和写相关的代码可以从对应语言的教程找到。

   用户界面可以设计为“菜单”方式，反复输出上述功能符号和所表示的意思，再加上“Ｑ”，表示退出（Quit）。每次用户输入一个选择功能符，在此功能执行完毕后再显示此菜单，直至某次用户选择了“Ｑ”为止。

   在执行I命令之后，哈夫曼树已经建好了。后面的每次执行不一定从Ｉ命令开始，可以换了ToBeTranslated.txt文件以后从E命令开始执行，这样就使用了前面的哈夫曼树给新的文件进行编码和译码等操作。

5. 选做内容：

   上述文件CodeFile.txt中的每个“0”或“1”实际上占用1个字节的空间，比较浪费空间。为最大限度地利用存储能力，可改成只占二进制的1位。修改你的程序，将编码结果以二进制数据的形式存放在文件CodeFile.dat中。

   修改你的程序，让它对你的源代码cpp文件进行编码和译码。

   让各个转换操作的源和目标文件都由用户在选择此操作时自己设定。

   使用效率更高的数据结构，降低程序的时间复杂度。

## 项目设计

1. 哈夫曼树类：

   * 里面存储一个哈夫曼树的格式，可以将这个类转换成内存中的哈夫曼树，也可以将这个类打印或转换成字符串。
   * 有一个接受`istream`类的构造函数，既可以是`cin`，也可以是`stringstream`，也可以是`ifstream`，来构建平均编码长度最小的最优树。
   * 有将其他格式直接转化成此类的构造函数
   * 内部存放键值对

   

2. 解码编码器类

   * 可以使用哈夫曼树类初始化这个类，且只有初始化之后才可以进行解码和编码操作
   * 接受一个`istream` (该类的mode是二进制形式的读入)类和一个`ostream` 类，对`istream`的输入进行编码，将结果输出到`ostream`中
   * 一个解码接口
   * 函数或者成员函数，将输出数据使用`bitset` 放到文件中
   
3. 一个二进制模块，负责以二进制的形式进行io （不一定真的有这个类，只是有这个功能）

   - 读取文件数据，将其转换成哈夫曼树类
   - 二进制编码数据转换成一个`istream`类 



## 参考链接

[如何改变ofstream内部的缓冲区大小？-CSDN社区](https://bbs.csdn.net/topics/260005411) 

[c++中ostream类的超详细说明 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/365950428) 

[GB2312是如何兼容ascii码的？](https://www.zhihu.com/question/37560234/answer/281885269 ) 

 
