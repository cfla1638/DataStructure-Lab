# 哈夫曼树

## 实验内容

1. 问题描述：利用哈夫曼编码进行通信可以大大提高信道利用率，缩短信息传输时间，降低传输成本。但是，这要求在发送端通过一个编码系统对待传数据预先编码，在接收端将传来的数据进行译码（复原）。对于双工信道（即可以双向传输信息的信道），每端都需要一个完整的编／译码系统。试为这样的信息收发站写一个哈夫曼码的编／译码系统。

 2. 基本要求：一个完整的系统应具有以下功能：

    Ｉ：初始化（Initialization）。用户输入字符个数n，n个字符和n个权值，建立哈夫曼树，并按自选的格式存入文本文件hfmTree.txt中。

    Ｅ：编码（Encoding）。利用已建好的哈夫曼树（如不在内存，则从文件hfmTree.txt中读入），对文本文件ToBeTranslated.txt中的正文进行编码，然后将结果存入文本文件CodeFile.txt中。

    Ｄ：译码（Decoding）。利用已建好的哈夫曼树将文件CodeFile.txt中的代码进行译码，结果存入文本文件TextFile.txt中。

    Ｐ：输出代码文件（Print）。将文件CodeFile.txt以每行50个字符的紧凑格式显示在屏幕上，并把屏幕上内容存入文本文件CodePrint.txt。

    Ｔ：输出哈夫曼树（Tree printing）。将已在内存中的哈夫曼树以直观的方式（树形或凹入表形式）显示在屏幕上，并把屏幕上的内容存入文本文件TreePrint.txt中。

3. 测试数据：见数据结构题集（C语言版）Ｐ149测试数据。

4. 实现提示：

   与文本文件的读和写相关的代码可以从对应语言的教程找到。

   用户界面可以设计为“菜单”方式，反复输出上述功能符号和所表示的意思，再加上“Ｑ”，表示退出（Quit）。每次用户输入一个选择功能符，在此功能执行完毕后再显示此菜单，直至某次用户选择了“Ｑ”为止。

   在执行I命令之后，哈夫曼树已经建好了。后面的每次执行不一定从Ｉ命令开始，可以换了ToBeTranslated.txt文件以后从E命令开始执行，这样就使用了前面的哈夫曼树给新的文件进行编码和译码等操作。

5. 选做内容：

   上述文件CodeFile.txt中的每个“0”或“1”实际上占用1个字节的空间，比较浪费空间。为最大限度地利用存储能力，可改成只占二进制的1位。修改你的程序，将编码结果以二进制数据的形式存放在文件CodeFile.dat中。

   修改你的程序，让它对你的源代码cpp文件进行编码和译码。

   让各个转换操作的源和目标文件都由用户在选择此操作时自己设定。

   使用效率更高的数据结构，降低程序的时间复杂度。

## 项目设计

本次实验完成了实验要求的基本内容和全部的选做内容。其中，选作内容(4) 使用更高效的数据结构，此程序使用了二叉堆。



文件结构

~~~shell
include:
 - binstream.h		# 二进制输入输出流
 - heap.h			# 二叉堆
 - huffmancoder.h	# 哈夫曼树和哈夫曼编码器
src:
 - binstream.cpp
 - huffmancoder.cpp
 - main.cpp
CMakeLists.txt
~~~



本项目分为3个模块

1. `HuffmanTree`类：

   介绍：存储一个哈夫曼树，可以使用此哈夫曼树初始化编码器

   接口说明：

   `HuffmanTree(std::vector<char>, std::vector<uint32_t>)`： 一个接受两个向量容器的构造函数，第一个容器存储要编码字符，第二个容器存储每个字符的权重。

   `HuffmanTree(std::istream &)`： 接受一个输入流的构造函数，可以统计这个流中的所有字符出现的次数，根据根据字符出现的次数自动构建最优树。可以从文件中输入，也可以从`cin` 中输入。

   `display()`：以凹入表的方式打印哈夫曼树

   `load(std::string)` ：从给定文件名的文件中按私有格式读取哈夫曼树

   `save(std::string)`：从给定文件名的文件中按私有格式存储哈夫曼树

   

2. `HuffmanCoder`类

   介绍：哈夫曼树编解码器
   
   接口说明：
   
   `set(const HuffmanTree &)` ：给这个编解码器设置一个哈夫曼树，使用这个哈夫曼树进行编解码。
   
   `encode(std::istream &, std::ostream &)` ：从一个`istream`中读取字符，以字符串的形式向 `ostream` 输入编码后的01串。
   
   `encode(std::istream &, obinstream &)` 从一个`istream`中读取字符，通过二进制输出流`obinstream` (定义在下) 以二进制流的形式写入编码后的文件。
   
   `decode(std::istream &, std::ostream &)` 从`istream` 中读取字符0或字符1，将解码后的字符串输出至`ostream` 
   
   `decode(ibinstream &, std::ostream &)` 从自定义的二进制输入流中按位读取，将解码后的字符输出至`ostream` 
   
    
   
3. `ibinstream` 类 和`obinstream` 类

   介绍：二进制输入和二进制输出流。

   设计这个模块是为了解决两个问题：

   1. 我们知道，读写文件的最小单位是字节，但由于哈夫曼编码是不定长编码，我们不能确定编码后的01串一定是8的倍数。因此，会出现最后几个01串不足以构成一个完整的字节的情况。

   2. 在向文件中写入哈夫曼编码时，由于哈夫曼编码是不定长的，我们不能在编码完一个字符后，立即将它的01串写入到文件流中，而是要先存储这个01流，等他构成一字节之后再向文件流中传输。为了不用时时刻刻地判断当前存储的01串长度是否大于8（大于8意味着它可以构成一个字节，输出），我们在这两个流内部建立了一个缓冲区，当缓冲区满后，再将缓冲区内的所有数据写入到文件流。

      虽然我们在流中建立了缓冲区，但因为c++的文件流中已经有缓冲区了，所以这里的缓冲区并不能减少与内存交互的频率。

      

   接口设计：

   `ibinstream` :

   `ibinstream(std::string)` ：接受一个存储着文件名的字符串的构造函数。

   `get(bool &)`  ：从流中读取1位（1bit）

   `open(std::string)` ： 打开一个文件

   `close()`  ：关闭文件流

   `is_open()`  ：检查文件是否打开

   

   `obinstream` :

   `obinstream(std::string)` ：接受一个存储着文件名的字符串的构造函数。

   `operator<<(std::string)` ：将一个只存储01字符的字符串写入流

   `rewind()` 将流定位到开头

   `open(std::string)` : 打开文件流

   `is_open() ` ：检查流是否打开

   `close()` ：将缓冲区内所有字节写入到文件，关闭文件流

   

   细节：

   在obinstream中，打开文件时（在构造函数中或在open函数中），首先向文件中写入一个字节的占位符，接着此对象正常工作。当写入到最后一个字节时，若此字节是不完整的，则此字节的高位用0填充，构成一个完整的字节，写入到文件中。接着，将流定位到文件开始处，将第一个占位符替换成最后一个字节的有有效位偏移。

    在ibinstream中，当打开文件时（构造函数或open()函数），首先读取第一个字节记录的最后一个字节的有效位偏移。接着正常读取，当读取到最后一个字节时，只读取最后一个字节的有效位（由读取的位偏移确定有效位）。



## 总结分析

1. 本次实验遇到了一个几个比较难改的bug，其中一个bug困扰了我很久：当清空`obinstream` 的缓冲区时，由于我的编码问题，会有可能丢失一个位，导致译码的内容从这个地方开始乱码。这个bug难以察觉的地方在于，虽然程序丢失了一个位，但由于Huffman编码是变长编码，译码内容可能会在乱码几个字符之后神奇的自校回来。如果不仔细看，是不能发现译码内容错误的。而且这个bug只有在译码内容的长度超过缓冲区大小时才会出现，而我的缓冲区设置的又比较大，小规模的测试数据是不能让这个bug出现的。

2. 为了防止在不同机器上，整数的大小不同，我使用了固定大小的`uint32_t` 来表示权值。

3. 本质上，Huffman编码就是对字节进行编码，而一字节不同位的排列组合只有256种，因此，Huffman树的最大结点数为 2 * 256 - 1 = 511。利用这一点，自己实现的优先队列，长度就可以定死为512。

   因为本质上Huffman编码的处理对象就是字节，因此我不仅可以用这个程序对文本文件进行编码，也可以对其他任意文件进行编码（这些文件都是以字节为单位）。经过我的测试，170k的文本文件经过Huffman编码后，大小可以缩减到100k。但对20M的视频进行编码，大小仅仅减小了几k，压缩效果不明显，我想，这应该是视频的不同字节出现的频率没有什么规律的结果。

## 编译

`MinGW` 

~~~shell
mkdir build
cd build
cmake -G "MinGW Makefiles" ..
cmake ..
make
~~~
